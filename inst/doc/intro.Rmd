---
title: "Introduction to functions"
author: "Yuning Dong"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Overview


在SA24204124-package包中，包含了两个函数。其中，Risk.R文件中的predict_stock_market_risk函数为基于滑动窗口的股票风险预测。Outlier.cpp文件中的rangeAnomalyDetection函数为基于范围的异常值检测。下面对这两个函数的功能做简要介绍并通过示例说明。


## 基于滑动窗口的股票风险预测

The source R code for _predict_stock_market_risk_ is as follows:

输入参数：股票收益率、影响因素1、影响因素2、影响因素3，滑动窗口大小默认为80。
对于每一次滑动窗口，将当前窗口的收益率标准差作为风险波动。做多元线性回归，将回归系数的加权和作为股市风险。
输出：股市风险预测值及其统计信息（均值、方差、极值），预测长度为n-window_size+1.
```{r,eval=FALSE}

predict_stock_market_risk <- function(stock_returns, x1, x2, x3, window_size = 80) {
  n <- length(stock_returns)
  
  #检查输入的参数长度是否一致
  if (n != length(x1) || n != length(x2) || n != length(x3)) {
    stop("All input data vectors must have the same length.")
  }
  
  # 检查窗口大小是否合法
  if (window_size <= 0 || window_size > n) {
    stop("Window size must be a positive integer and smaller than or equal to the length of the data.")
  }
  
  #存储风险预测结果
  risk_predictions <- numeric(n - window_size + 1)
  
  for (i in 1:(n - window_size + 1)) {
    # 提取当前窗口的数据
    current_window_stock_returns <- stock_returns[i:(i + window_size - 1)]
    current_window1 <- x1[i:(i + window_size - 1)]
    current_window2 <- x2[i:(i + window_size - 1)]
    current_window3 <- x3[i:(i + window_size - 1)]
    
    # 检查窗口内是否包含NA值
    if (any(is.na(current_window_stock_returns)) || any(is.na(current_window1)) || 
        any(is.na(current_window2)) || any(is.na(current_window3))) {
      risk_predictions[i] <- NA  # 如果窗口内有NA值，设置风险为NA
      next
    }
    
    # 计算当前窗口股市收益率的标准差作为风险
    current_risk <- sd(current_window_stock_returns)
    
    # 将经济因素（x1, x2, x3）合并成一个数据框
    data <- data.frame(current_risk = rep(current_risk, length(current_window1)), x1 = current_window1, x2 = current_window2, x3 = current_window3)
  
    
    # 多元线性回归：股市风险 ~ GDP + 通货膨胀率 + 失业率
    model <- lm(current_risk ~ x1 + x2 + x3, data = data)
    
    # 提取回归模型的系数
    coefficients <- coef(model)
    
    # 计算回归模型的预测值（即股市风险）
    predicted_risk <- sum(coefficients[-1] * c(mean(current_window1), mean(current_window2), mean(current_window3))) + coefficients[1]
    
    # 存储预测的风险值
    risk_predictions[i] <- predicted_risk
  }
  
  # 输出预测结果和统计信息
  result <- list(
    risk_predictions = risk_predictions,
    mean_risk = mean(risk_predictions, na.rm = TRUE),
    sd_risk = sd(risk_predictions, na.rm = TRUE),
    min_risk = min(risk_predictions, na.rm = TRUE),
    max_risk = max(risk_predictions, na.rm = TRUE)
  )
  
  return(result)
}
```

用随机数作为简单的示例代码：
```{r}
# 示例数据生成
library(SA24204124)
set.seed(123)  # 设置随机种子确保可重复性
stock_returns <- rnorm(200)  # 模拟100个股市收益率
gdp_growth <- rnorm(200)  # 模拟100个GDP增长率
inflation_rate <- rnorm(200)  # 模拟100个通货膨胀率
unemployment_rate <- rnorm(200)  # 模拟100个失业率

# 调用函数进行风险预测
result <- predict_stock_market_risk(stock_returns, gdp_growth, inflation_rate, unemployment_rate, window_size = 80)

# 查看结果
print("风险预测结果：")
print(result$risk_predictions)  # 每个窗口的风险预测

print("预测统计信息：")
print(result$mean_risk)  # 风险的均值
print(result$sd_risk)    # 风险的标准差
print(result$min_risk)   # 风险的最小值
print(result$max_risk)   # 风险的最大值

# 查看结果
plot(result$risk_predictions, type = "l", col = "blue", main = "Predicted Stock Market Risk", ylab = "Risk Value", xlab = "Time")
```

用data数据集作为实例，测试函数功能。在data数据集中，收集了2000年-2023年标普500指数的年收益率和中国人均GDP增速，通货膨胀率和年度失业率。

其中，标普500指数的年收益率(SP_Return)数据来源于yahho（https://finance.yahoo.com/quote/%5EGSPC/）。
计算公式：年度收益率=（年末收盘价-年初收盘价）/年初收盘价。

中国人均GDP增速、通货膨胀率和年度失业率均来自世界银行数据库，网站：https://data.worldbank.org/。

```{r}
data(data)
Year = data$Year; SP_Return = data$SP_Return; GDP = data$GDP; Inflation = data$Inflation; Unemployment = data$Unemployment
plot(Year, SP_Return, col = 'blue', type = 'l', lwd = 2, main = 'data', ylim = c(-1,15))
lines(Year, GDP, col = 'red', lwd = 2)
lines(Year, Inflation, col = 'green', lwd = 2)
lines(Year, Unemployment, col = 'yellow', lwd = 2)
legend("topleft", legend = c("SP500 yearly return", "GDP growth", "Inflation", "Unemployment rate"),
       col = c("blue", "red", "green", "yellow"), lwd = 2)

```


用Risk.R文件中的 _predict_stock_market_risk_ 预测2024-2038这15年间的标普500对于中国的股市风险。

```{r,eval=FALSE}
data(data)
SP_Return = data$SP_Return; GDP = data$GDP; Inflation = data$Inflation; Unemployment = data$Unemployment
predict_stock_market_risk(SP_Return,GDP,Inflation,Unemployment,window_size=10)
r1 = predict_stock_market_risk(SP_Return,GDP,Inflation,Unemployment,window_size=10)$risk_predictions
plot(seq(2024,2038),r1,ylab = 'Stock Risk Value',type = 'l')

```





## 基于范围的异常值处理

The source R code for _rangeAnomalyDetection_ in Outlier.cpp is as follows:

输入参数：
```{r,eval=FALSE}
List rangeAnomalyDetection(DataFrame df, Nullable<List> value_ranges = R_NilValue) {
  
  // 创建一个空的列表来存储异常值
  List anomalies;
  
  // 如果没有提供范围，自动基于 IQR 计算范围
  if (value_ranges.isNull()) {
    List ranges;
    
    // 获取 quantile 函数
    Function quantile("quantile");
    
    for (int i = 0; i < df.size(); i++) {
      CharacterVector colnames = df.names();
      String colname = colnames[i];
      NumericVector column = df[colname];
      
      if (Rf_isNumeric(column)) {
        // 调用 R 中的 quantile 函数计算 Q1 和 Q3
        NumericVector Q1 = quantile(column, 0.25);
        NumericVector Q3 = quantile(column, 0.75);
        double IQR = Q3[0] - Q1[0];
        
        double lower_bound = Q1[0] - 1.5 * IQR;
        double upper_bound = Q3[0] + 1.5 * IQR;
        
        NumericVector range = NumericVector::create(lower_bound, upper_bound);
        ranges.push_back(range, colname);
      }
    }
    
    // 设置范围值
    value_ranges = wrap(ranges);
  }
  
  // 获取列名
  CharacterVector colnames = df.names();
  
  // 存储剔除异常值后的数据框
  DataFrame cleaned_df = df;
  
  // 存储异常值的索引
  List anomalies_list(df.size());
  
  // 标记超出范围的异常值
  LogicalVector rows_to_keep(df.nrows(), true); // 标记哪些行需要保留（初始为保留所有行）
  for (int i = 0; i < df.size(); i++) {
    String colname = colnames[i];
    NumericVector column = df[colname];
    
    if (Rf_isNumeric(column)) {
      // 使用 get() 解包 value_ranges，获取列表
      List unwrapped_value_ranges = as<List>(value_ranges);
      // 获取指定列的范围
      NumericVector range = unwrapped_value_ranges[colname];
      double lower_bound = range[0];
      double upper_bound = range[1];
      
      // 使用 Rcpp::which() 查找超出范围的异常值
      IntegerVector outlier_indices;
      for (int j = 0; j < column.size(); j++) {
        if (column[j] < lower_bound || column[j] > upper_bound) {
          outlier_indices.push_back(j + 1);  // 索引从 1 开始
          rows_to_keep[j] = false; // 标记为不保留
        }
      }
      
      anomalies.push_back(outlier_indices, colname);
  
    }
  }
  
  // 使用 rows_to_keep 标记过滤出保留的行
  cleaned_df = cleaned_df[rows_to_keep];
  
  // 返回包含异常值的记录和计算的范围
  return List::create(Named("anomalies") = anomalies, //返回异常值的索引
                      Named("value_ranges") = value_ranges, //返回正常值范围
                      Named("cleaned_df") = cleaned_df); // 返回剔除异常值后的数据框
}


```



示例代码1：df数据集分别给出了6个温度和气压值。ranges数据集为存储两个向量的列表，分别代表温度和气压的正常范围，假设温度正常范围为[-50,50]，气压的正常范围为[980,1050]。
```{r,eval=FALSE}
library(SA24204124)
df <- data.frame(
  temp = c(25, 30, 35, 100, -60, 15),
  pressure = c(1010, 1020, 1015, 1030, 1100, 1005)
)

# 指定合理的范围
ranges <- list(
  temp = c(-50, 50),  # 温度应该在 -50 到 50 摄氏度之间
  pressure = c(980, 1050)  # 气压应该在 980 到 1050 毫巴之间
)

# 检测异常值
r2 = rangeAnomalyDetection(df, value_ranges = ranges)

# 查看检测结果
print(r2)
```

示例代码2：范围为默认参数（及四分位数）

```{r}
library(SA24204124)

# 生成两组随机数数据
df2 <- data.frame(
  d1 = runif(10, -30, 40), # 温度数据，包含一个极端值
  d2 = runif(10, 900, 1100)  # 气压数据，包含一个极端值
)

# 打印数据框
print(df2)

# 调用 rangeAnomalyDetection 函数，检测异常值（不提供 value_ranges 参数，使用默认 IQR 计算范围）
r22 = rangeAnomalyDetection(df2)

# 显示异常值
print(r22)


```







