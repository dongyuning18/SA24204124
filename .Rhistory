}
## 定义表达式函数
expr = function(a,k){
iintegral = function(u){
integral(u,k)
}
c = getc(a,k-1)
res = 2/sqrt(pi*(k-1)) * exp(lgamma(k/2) - lgamma((k-1)/2)) * integrate(iintegral,lower = 0, upper = c)$value
return(res)
}
g = function(a){
expr(a,k) - expr(a,k+1)
}
## 求解方程并输出结果
resl = function(k){
e = 0.01
if (g(e) < 0 && g(sqrt(k) - e) > 0 || g(e) > 0 && g(sqrt(k) - e) < 0) {
r = uniroot(g, c(e,sqrt(k)-e))$root
} else {
r = NA
}
return(r)
}
for (k in c(4:25,100,500,1000)){
print(resl(k))
}
## 定义生成函数
expr2 = function(a,k){
1-pt(sqrt(a^2*k/(k+1-a^2)), df = k)
}
g2 = function(a){  # 等式函数
expr2(a,k) - expr2(a,k-1)
}
reslt = function(k){ # 解方程
e = 0.01
r = uniroot(g2, interval = c(e,sqrt(k) - e))$root
return(r)
}
# 输出结果对比
for(k in c(4:25,100,500,1000)){
p = round(c('integral solution' = resl(k),'probability solution' = reslt(k)), 3)
print(p)
}
yo = c(0.54, 0.48, 0.33, 0.43, 1.00, 1.00, 0.91, 1.00, 0.21, 0.85)
n = length(yo)
## 定义生成函数
lambda = function(){ # 原始观测数据的lambda估计
1/mean(yo)
}
## 统计推断函数: E-M算法
em = function(tau){
# E算法
lambda0 = lambda()
yad = yo
for(i in 1:1000){ # 迭代1000次
# 对于修改的数据，其期望E[T|T>tau] = tao + 1/lambda
expectedgv = tau + 1/lambda0
# 将值为1的数据改为期望值
yad[yo == tau] = expectedgv
# 更新lambda
lambda0 = 1/mean(yad)
}
return(lambda0)
}
## 结果输出函数
reslt3 = function(){
round(rbind(c('E-M Algorithm' = em(1), 'Observed Data MLE' = lambda())),3)
}
reslt3()
#install.packages('nloptr')
library(nloptr)
eval_f = function(x){
return('objective'=4*x[1]+2*x[2]+9*x[3])
}
eval_g = function(x){
return(list('constraints'=c(2*x[1]+x[2]+x[3]-2,x[1]-x[2]+3*x[3]-3),
'jacobian'=rbind(c(2,1,1),c(1,-1,3))))
}
res2=nloptr(x0 = c(1,1,1),
eval_f = eval_f,
lb = c(0,0,0),
ub = c(Inf,Inf,Inf),
eval_g_ineq = eval_g,
opts = list('algorithm'='NLOPT_LN_COBYLA',"xtol_rel"=1.0e-6))
res2$solution
res2$objective
data(mtcars)
formulas <- list(
mtcars$mpg ~ mtcars$disp,
mtcars$mpg ~ I(1 / mtcars$disp),
mtcars$mpg ~ mtcars$disp + mtcars$wt,
mtcars$mpg ~ I(1 / mtcars$disp) + mtcars$wt
)
## 使用for循环
loop_res = list()
for(i in 1:4){
loop_res[[i]] = lm(formulas[[i]])
}
cat("循环输出结果为：",'\n')
print(loop_res)
## 使用lapply函数
cat("lapply函数输出结果为：",'\n')
lapply(formulas, function(f) lm(f, data = mtcars))
data(mtcars)
bootstraps <- lapply(1:10, function(i) {
rows <- sample(1:nrow(mtcars), rep = TRUE)
mtcars[rows, ]
})
## 使用for循环
loop_res2 = list()
for(i in 1:10){
loop_res2[[i]] = lm(mtcars$mpg~mtcars$disp,data=bootstraps[[i]])
}
cat("循环输出结果为：",'\n')
print(loop_res2)
## 使用lapply函数，并且不使用匿名函数
a = function(data){
lm(mtcars$mpg~mtcars$disp, data = data)
}
cat("lapply函数输出结果为：",'\n')
lapply(bootstraps, a)
rsq <- function(mod) summary(mod)$r.squared
res_rsquare = function(){
for(i in 1:4) {
r1 = rsq(lm(formulas[[i]]))
p1 = formulas[[i]]
print(c(formulas[[i]],r1))
}
for(j in 1:10) {
r2 = rsq(lm(bootstraps[[j]]))
p2 = paste('bootstraps', j,':')
print(c(p2, r2))
}
}
res_rsquare()
trials <- replicate(
100,
t.test(rpois(10, 10), rpois(7, 10)),
simplify = FALSE
)
## 使用slapply函数：
cat("使用sapply函数：",'\n')
sapply(trials, function(x) x$p.value)
## extra challenge：
p = numeric(100)
cat("直接调用p值：",'\n')
for (i in 1:100){
p[i] = trials[[i]]$p.value
}
print(p)
x1 = 1:4
x2 = runif(4)
f = function(x,y){
x/y
}
res_it = simplify2array(Map(f, x1, x2))
vapply(res_it, quantile, c(1,2,5,6,8))
## 定义统计推断函数（计算chi-square）
infer_chi = function(inputs){
# 获取inputs矩阵的行和与列和
nrow = nrow(inputs) # 行和
ncol = ncol(inputs) # 列和
#获取总样本量
N = sum(inputs)
#获取每行与每列之和
sumrow = rowSums(inputs)
sumcol = colSums(inputs)
#计算期望函数
exp = outer(sumrow,sumcol)/N
#计算卡方统计量
chi_square = (inputs-exp)^2/exp
return(sum(chi_square))
}
## 输出结果
inputs = matrix(c(2,3,15,10,20,10), nrow = 2, byrow = TRUE)
infer_chi(inputs)
## 定义table函数
tablef = function(x,y){
# 获取输入向量的最大值和范围
max_x <- max(x)
max_y <- max(y)
# 初始化一个计数矩阵
count_matrix <- matrix(0, nrow = max_x, ncol = max_y)
# 使用矩阵索引计数
for (i in max(seq_along(x),seq_along(y)) ){
count_matrix[x[i], y[i]] <- count_matrix[x[i], y[i]] + 1
}
return(count_matrix)
}
## 结果输出函数
res_table = function(x,y){
result <- tablef(x, y)
return(result)
}
x = c(1,3,6,9,12)
y = c(2,4,5,7,15)
cat("重新定义的table函数：",'\n')
res_table(x,y)
## 加速卡方检验
fast_chi = function(observed){
inputs = tablef(observed[1], observed[2])
# 获取inputs矩阵的行和与列和
nrow = nrow(inputs) # 行和
ncol = ncol(inputs) # 列和
#获取总样本量
N = sum(inputs)
#获取每行与每列之和
sumrow = rowSums(inputs)
sumcol = colSums(inputs)
#计算期望函数
exp = outer(sumrow,sumcol)/N
#计算卡方统计量
chi_square = (inputs-exp)^2/exp
return(sum(chi_square))
}
observed = matrix(c(1,4,3,2,5,5,3,2,4,1,5,3), nrow = 2, byrow = TRUE)
cat("加速卡方检验的统计量：",'\n')
fast_chi(observed)
tablef <- function(numbers) {
# 创建一个空的列表来存储数字及其对应的频数
freq_list <- list()
# 遍历输入的数字
for (num in numbers) {
# 如果数字已经在列表中，增加其频数
if (num %in% names(freq_list)) {
freq_list[[as.character(num)]] <- freq_list[[as.character(num)]] + 1
} else {
# 如果数字不在列表中，添加它并设置频数为1
freq_list[[as.character(num)]] <- 1
}
}
# 将列表转换为两个向量：唯一的数字和对应的频数
unique_numbers <- as.numeric(names(freq_list))
frequencies <- as.numeric(unlist(freq_list))
# 构建矩阵
result_matrix <- matrix(c(unique_numbers, frequencies), nrow = 2, byrow = TRUE)
return(result_matrix)
}
# 示例数据
x <- c(1,3,1,1,4,2,2,4,3,5)
# 调用快速 table 函数
result <- tablef(x)
cat("重新定义的table函数：",'\n')
print(result)
fast_chi = function(numbers){
inputs = tablef(numbers)
# 获取inputs矩阵的行和与列和
nrow = nrow(inputs) # 行和
ncol = ncol(inputs) # 列和
#获取总样本量
N = sum(inputs)
#获取每行与每列之和
sumrow = rowSums(inputs)
sumcol = colSums(inputs)
#计算期望函数
exp = outer(sumrow,sumcol)/N
#计算卡方统计量
chi_square = (inputs-exp)^2/exp
return(sum(chi_square))
}
observed = matrix(c(1,3,1,1,4,2,2,4,3,5), nrow = 2, byrow = TRUE)
cat("加速卡方检验的统计量：",'\n')
fast_chi(observed)
library(Rcpp)
#dir_cpp <- '../Homework-2024.11.18/'
#sourceCpp(paste0(dir_cpp,"gibbs_sampler.cpp"))
dir_cpp <- "C:/Users/36070/g1/tjjs/Homework-2024.11.18"
file_path <- file.path(dir_cpp, "gibbs_sampler.cpp")
sourceCpp("C:/Users/36070/g1/tjjs/Homework-2024.11.18/gibbs_sampler.cpp")
# 运行 Gibbs 采样
samples <- gibbs_sampler(10, 2, 2)
# 查看采样结果
head(samples)
# 绘制采样结果
plot(samples[,1], xlab = "x",  type = 'l', main = "Trace of X")
hist(samples[,1], breaks = seq(-0.5, 10 + 0.5, by = 1), main = "Histogram of x", xlab = "x", probability = TRUE)
plot(samples[,2], xlab = "y",  type = 'l', main = "Trace of Y")
hist(samples[,2], breaks = 30, main = "Histogram of y", xlab = "y", probability = TRUE)
set.seed(123) # 设置随机种子
N <- 4000 # 样本大小
rd_generation = function(n, a, b){
#二项分布：Binomial(n, y),其中n=10,y=0.3
binomial_s <- rbinom(N, size = n, prob = 0.3) # 生成二项分布随机数
binomial_t <- qbinom(ppoints(N), size = n, prob = 0.3) # 生成理论分位数
# 贝塔分布：Beta(x+a, n-x+b),其中x=5, n=10, a=b=2
beta_s <- rbeta(N,  5+a, n-5+b) # 生成贝塔分布随机数
beta_t <- qbeta(ppoints(N), 5+a, n-5+b) # 生成理论分位数
return(list(binomial_s,binomial_t, beta_s, beta_t))
}
rd_generation_result = rd_generation(10,2,2)
# 绘制 二项分布的Q-Q 图
qqplot(rd_generation_result[[2]], rd_generation_result[[1]],
main = "Binomial(10, 0.3)",col = "blue")
abline(0, 1, col = "red", lwd = 2) # 添加参考线
# 绘制 贝塔分布Q-Q 图
qqplot(rd_generation_result[[4]], rd_generation_result[[3]],
main = "Beta(7, 7)",col = "blue")
abline(0, 1, col = "red", lwd = 2) # 添加参考线
library(Rcpp)
sourceCpp("gibbs_sampler.cpp")
library(Rcpp)
sourceCpp("C:/Users/36070/g1/tjjs/Homework-2024.11.18/gibbs_sampler.cpp")
library(microbenchmark)
ts = microbenchmark(ts_gibbs = gibbs_sampler(10,2,2), ts_rd = rd_generation(10,2,2))
summary(ts)
c(runif(10, -30, 40), 100)
runif(10, -30, 40)
# 载入你自己编写的 R 包
library(SA24204124)
# 设置随机数种子
set.seed(123)
# 生成两组随机数数据
df <- data.frame(
d1 = runif(10, -30, 40), # 温度数据，包含一个极端值
d2 = runif(10, 900, 1100)  # 气压数据，包含一个极端值
)
# 打印数据框
print(df)
# 调用 rangeAnomalyDetection 函数，检测异常值（不提供 value_ranges 参数，使用默认 IQR 计算范围）
r22 <- rangeAnomalyDetection(df)
# 显示异常值
print(r22)
library(SA24204124)
# 生成两组随机数数据
df <- data.frame(
d1 = runif(10, -30, 40), # 温度数据，包含一个极端值
d2 = runif(10, 900, 1100)  # 气压数据，包含一个极端值
)
# 打印数据框
print(df)
# 调用 rangeAnomalyDetection 函数，检测异常值（不提供 value_ranges 参数，使用默认 IQR 计算范围）
r22 <- rangeAnomalyDetection(df)
# 显示异常值
print(r22)
devtools::document()
devtools::check()
library(SA24204124)
df <- data.frame(
temp = c(25, 30, 35, 100, -60, 15),
pressure = c(1010, 1020, 1015, 1030, 1100, 1005)
)
# 指定合理的范围
ranges <- list(
temp = c(-50, 50),  # 温度应该在 -50 到 50 摄氏度之间
pressure = c(980, 1050)  # 气压应该在 980 到 1050 毫巴之间
)
# 检测异常值
r2 = rangeAnomalyDetection(df, value_ranges = ranges)
# 查看检测结果
print(r2)
library(SA24204124)
# 生成两组随机数数据
df2 <- data.frame(
d1 = runif(10, -30, 40), # 温度数据，包含一个极端值
d2 = runif(10, 900, 1100)  # 气压数据，包含一个极端值
)
# 打印数据框
print(df2)
# 调用 rangeAnomalyDetection 函数，检测异常值（不提供 value_ranges 参数，使用默认 IQR 计算范围）
r22 = rangeAnomalyDetection(df2)
# 显示异常值
print(r22)
devtools::check()
# 设置参数
n <- 10      # 样本大小
a <- 2       # Beta分布的参数
b <- 2       # Beta分布的参数
N <- 5000  # Gibbs采样的迭代次数
burn = 1000
# 1. 生成Gibbs采样的数据
generate_samples <- function(n, a, b, iterations) {
x_samples <- numeric(iterations)
y_samples <- numeric(iterations)
y <- 0.5  # 初始化 y 的初始值
for (i in 1:iterations) {
x <- rbinom(1, n, y)              # 从 x | y 的条件分布采样
y <- rbeta(1, x + a, n - x + b)   # 从 y | x 的条件分布采样
x_samples[i] <- x
y_samples[i] <- y
xx_samples = x_samples[(burn+1):N] # 取1001-5000样本
yy_samples = y_samples[(burn+1):N]
}
return(list(xx_samples = xx_samples, yy_samples = yy_samples))
}
# 2. 进行统计推断
statistical_analysis <- function(samples) {
xx = samples$xx_samples
yy = samples$yy_samples
x_mean <- mean(xx)
y_mean <- mean(yy)
x_var <- var(xx)
y_var <- var(yy)
return(list(x_mean = x_mean, y_mean = y_mean, x_var = x_var, y_var = y_var))
}
# 3. 输出结果，包括轨迹图和直方图
plot_results <- function(samples) {
par(mfrow = c(5, 5, 2, 2))
# x 和 y 的轨迹图
plot(samples$xx_samples, type = "l", main = "Trace of x", xlab = "Iteration", ylab = "x")
plot(samples$yy_samples, type = "l", main = "Trace of y", xlab = "Iteration", ylab = "y")
# x 和 y 的直方图
hist(samples$xx_samples, breaks = seq(-0.5, n + 0.5, by = 1), main = "Histogram of x", xlab = "x", probability = TRUE)
hist(samples$yy_samples, breaks = 30, main = "Histogram of y", xlab = "y", probability = TRUE)
}
# 主程序
samples <- generate_samples(n, a, b, N)        # 生成样本
analysis_results <- statistical_analysis(samples)        # 统计推断
plot_results(samples)                                    # 输出结果
# 设置参数
n <- 10      # 样本大小
a <- 2       # Beta分布的参数
b <- 2       # Beta分布的参数
N <- 5000  # Gibbs采样的迭代次数
burn = 1000
# 1. 生成Gibbs采样的数据
generate_samples <- function(n, a, b, iterations) {
x_samples <- numeric(iterations)
y_samples <- numeric(iterations)
y <- 0.5  # 初始化 y 的初始值
for (i in 1:iterations) {
x <- rbinom(1, n, y)              # 从 x | y 的条件分布采样
y <- rbeta(1, x + a, n - x + b)   # 从 y | x 的条件分布采样
x_samples[i] <- x
y_samples[i] <- y
xx_samples = x_samples[(burn+1):N] # 取1001-5000样本
yy_samples = y_samples[(burn+1):N]
}
return(list(xx_samples = xx_samples, yy_samples = yy_samples))
}
# 2. 进行统计推断
statistical_analysis <- function(samples) {
xx = samples$xx_samples
yy = samples$yy_samples
x_mean <- mean(xx)
y_mean <- mean(yy)
x_var <- var(xx)
y_var <- var(yy)
return(list(x_mean = x_mean, y_mean = y_mean, x_var = x_var, y_var = y_var))
}
# 3. 输出结果，包括轨迹图和直方图
plot_results <- function(samples) {
par(mfrow = c( 2, 2))
# x 和 y 的轨迹图
plot(samples$xx_samples, type = "l", main = "Trace of x", xlab = "Iteration", ylab = "x")
plot(samples$yy_samples, type = "l", main = "Trace of y", xlab = "Iteration", ylab = "y")
# x 和 y 的直方图
hist(samples$xx_samples, breaks = seq(-0.5, n + 0.5, by = 1), main = "Histogram of x", xlab = "x", probability = TRUE)
hist(samples$yy_samples, breaks = 30, main = "Histogram of y", xlab = "y", probability = TRUE)
}
# 主程序
samples <- generate_samples(n, a, b, N)        # 生成样本
analysis_results <- statistical_analysis(samples)        # 统计推断
plot_results(samples)                                    # 输出结果
# 打印统计推断的结果
print(analysis_results)
library(Rcpp)
devtools::load_all()
devtools::document()
devtools::check()
# 加载需要的库
library(grid)
# 读取图片文件
img <- readJPEG("Exercise-Proof.jpg")
grid.newpage()
# 插入图片
grid.raster(img)
devtools::check()
devtools::check()
devtools::check()
devtools::build_vignettes()
devtools::build(vignettes=FALSE)
install.packages('../SA24204124_1.0.tar.gz',repo=NULL)
install.packages('../StatComp_1.0.tar.gz',repo=NULL)
install.packages('../SA24204124_1.0.tar.gz',repo=NULL)
install.packages('../SA24204124_1.0.tar.gz',repo=NULL)
devtools::document()
devtools::install_github("dongyuning18/SA24204124")
devtools::install_github("dongyuning18/SA24204124@main")
devtools::install_github("dongyuning18/SA24204124@master")
git clone https://github.com/dongyuning18/SA24204124.git
setwd("SA24204124")
devtools::install()
install.packages('xfun')
packageVersion("xfun")
devtools::install()
devtools::install_github("dongyuning18/SA24204124")
devtools::install_github("dongyuning18/SA24204124@master")
devtools::install_github("CCLLYS/SA24204125")
install.packages('glue')
devtools::install_github("CCLLYS/SA24204125")
devtools::install_github("CCLLYS/SA24204125", force = TRUE)
packageVersion("glue")
install.packages('withr')
devtools::install_github("CCLLYS/SA24204125", force = TRUE)
devtools::install_github("dongyuning18/SA24204124@master")
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
devtools::install_github("CCLLYS/SA24204125", force = TRUE)
view(SA24204125)
View(SA24204125)
?SA2420412
??SA24204125
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
devtools::install_github("dongyuning18/SA24204124")
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
install.packages('curl')
install.packages('fs')
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
data(data)
SP_Return = data$SP_Return; GDP = data$GDP; Inflation = data$Inflation; Unemployment = data$Unemployment
data(data)
Year = data$Year; SP_Return = data$SP_Return; GDP = data$GDP; Inflation = data$Inflation; Unemployment = data$Unemployment
