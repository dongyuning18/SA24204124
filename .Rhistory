N = sum(inputs)
#获取每行与每列之和
sumrow = rowSums(inputs)
sumcol = colSums(inputs)
#计算期望函数
exp = outer(sumrow,sumcol)/N
#计算卡方统计量
chi_square = (inputs-exp)^2/exp
return(sum(chi_square))
}
observed = matrix(c(1,4,3,2,5,5,3,2,4,1,5,3), nrow = 2, byrow = TRUE)
cat("加速卡方检验的统计量：",'\n')
fast_chi(observed)
tablef <- function(numbers) {
# 创建一个空的列表来存储数字及其对应的频数
freq_list <- list()
# 遍历输入的数字
for (num in numbers) {
# 如果数字已经在列表中，增加其频数
if (num %in% names(freq_list)) {
freq_list[[as.character(num)]] <- freq_list[[as.character(num)]] + 1
} else {
# 如果数字不在列表中，添加它并设置频数为1
freq_list[[as.character(num)]] <- 1
}
}
# 将列表转换为两个向量：唯一的数字和对应的频数
unique_numbers <- as.numeric(names(freq_list))
frequencies <- as.numeric(unlist(freq_list))
# 构建矩阵
result_matrix <- matrix(c(unique_numbers, frequencies), nrow = 2, byrow = TRUE)
return(result_matrix)
}
# 示例数据
x <- c(1,3,1,1,4,2,2,4,3,5)
# 调用快速 table 函数
result <- tablef(x)
cat("重新定义的table函数：",'\n')
print(result)
fast_chi = function(numbers){
inputs = tablef(numbers)
# 获取inputs矩阵的行和与列和
nrow = nrow(inputs) # 行和
ncol = ncol(inputs) # 列和
#获取总样本量
N = sum(inputs)
#获取每行与每列之和
sumrow = rowSums(inputs)
sumcol = colSums(inputs)
#计算期望函数
exp = outer(sumrow,sumcol)/N
#计算卡方统计量
chi_square = (inputs-exp)^2/exp
return(sum(chi_square))
}
observed = matrix(c(1,3,1,1,4,2,2,4,3,5), nrow = 2, byrow = TRUE)
cat("加速卡方检验的统计量：",'\n')
fast_chi(observed)
library(Rcpp)
#dir_cpp <- '../Homework-2024.11.18/'
#sourceCpp(paste0(dir_cpp,"gibbs_sampler.cpp"))
dir_cpp <- "C:/Users/36070/g1/tjjs/Homework-2024.11.18"
file_path <- file.path(dir_cpp, "gibbs_sampler.cpp")
sourceCpp("C:/Users/36070/g1/tjjs/Homework-2024.11.18/gibbs_sampler.cpp")
# 运行 Gibbs 采样
samples <- gibbs_sampler(10, 2, 2)
# 查看采样结果
head(samples)
# 绘制采样结果
plot(samples[,1], xlab = "x",  type = 'l', main = "Trace of X")
hist(samples[,1], breaks = seq(-0.5, 10 + 0.5, by = 1), main = "Histogram of x", xlab = "x", probability = TRUE)
plot(samples[,2], xlab = "y",  type = 'l', main = "Trace of Y")
hist(samples[,2], breaks = 30, main = "Histogram of y", xlab = "y", probability = TRUE)
set.seed(123) # 设置随机种子
N <- 4000 # 样本大小
rd_generation = function(n, a, b){
#二项分布：Binomial(n, y),其中n=10,y=0.3
binomial_s <- rbinom(N, size = n, prob = 0.3) # 生成二项分布随机数
binomial_t <- qbinom(ppoints(N), size = n, prob = 0.3) # 生成理论分位数
# 贝塔分布：Beta(x+a, n-x+b),其中x=5, n=10, a=b=2
beta_s <- rbeta(N,  5+a, n-5+b) # 生成贝塔分布随机数
beta_t <- qbeta(ppoints(N), 5+a, n-5+b) # 生成理论分位数
return(list(binomial_s,binomial_t, beta_s, beta_t))
}
rd_generation_result = rd_generation(10,2,2)
# 绘制 二项分布的Q-Q 图
qqplot(rd_generation_result[[2]], rd_generation_result[[1]],
main = "Binomial(10, 0.3)",col = "blue")
abline(0, 1, col = "red", lwd = 2) # 添加参考线
# 绘制 贝塔分布Q-Q 图
qqplot(rd_generation_result[[4]], rd_generation_result[[3]],
main = "Beta(7, 7)",col = "blue")
abline(0, 1, col = "red", lwd = 2) # 添加参考线
library(Rcpp)
sourceCpp("gibbs_sampler.cpp")
library(Rcpp)
sourceCpp("C:/Users/36070/g1/tjjs/Homework-2024.11.18/gibbs_sampler.cpp")
library(microbenchmark)
ts = microbenchmark(ts_gibbs = gibbs_sampler(10,2,2), ts_rd = rd_generation(10,2,2))
summary(ts)
c(runif(10, -30, 40), 100)
runif(10, -30, 40)
# 载入你自己编写的 R 包
library(SA24204124)
# 设置随机数种子
set.seed(123)
# 生成两组随机数数据
df <- data.frame(
d1 = runif(10, -30, 40), # 温度数据，包含一个极端值
d2 = runif(10, 900, 1100)  # 气压数据，包含一个极端值
)
# 打印数据框
print(df)
# 调用 rangeAnomalyDetection 函数，检测异常值（不提供 value_ranges 参数，使用默认 IQR 计算范围）
r22 <- rangeAnomalyDetection(df)
# 显示异常值
print(r22)
library(SA24204124)
# 生成两组随机数数据
df <- data.frame(
d1 = runif(10, -30, 40), # 温度数据，包含一个极端值
d2 = runif(10, 900, 1100)  # 气压数据，包含一个极端值
)
# 打印数据框
print(df)
# 调用 rangeAnomalyDetection 函数，检测异常值（不提供 value_ranges 参数，使用默认 IQR 计算范围）
r22 <- rangeAnomalyDetection(df)
# 显示异常值
print(r22)
devtools::document()
devtools::check()
library(SA24204124)
df <- data.frame(
temp = c(25, 30, 35, 100, -60, 15),
pressure = c(1010, 1020, 1015, 1030, 1100, 1005)
)
# 指定合理的范围
ranges <- list(
temp = c(-50, 50),  # 温度应该在 -50 到 50 摄氏度之间
pressure = c(980, 1050)  # 气压应该在 980 到 1050 毫巴之间
)
# 检测异常值
r2 = rangeAnomalyDetection(df, value_ranges = ranges)
# 查看检测结果
print(r2)
library(SA24204124)
# 生成两组随机数数据
df2 <- data.frame(
d1 = runif(10, -30, 40), # 温度数据，包含一个极端值
d2 = runif(10, 900, 1100)  # 气压数据，包含一个极端值
)
# 打印数据框
print(df2)
# 调用 rangeAnomalyDetection 函数，检测异常值（不提供 value_ranges 参数，使用默认 IQR 计算范围）
r22 = rangeAnomalyDetection(df2)
# 显示异常值
print(r22)
devtools::check()
# 设置参数
n <- 10      # 样本大小
a <- 2       # Beta分布的参数
b <- 2       # Beta分布的参数
N <- 5000  # Gibbs采样的迭代次数
burn = 1000
# 1. 生成Gibbs采样的数据
generate_samples <- function(n, a, b, iterations) {
x_samples <- numeric(iterations)
y_samples <- numeric(iterations)
y <- 0.5  # 初始化 y 的初始值
for (i in 1:iterations) {
x <- rbinom(1, n, y)              # 从 x | y 的条件分布采样
y <- rbeta(1, x + a, n - x + b)   # 从 y | x 的条件分布采样
x_samples[i] <- x
y_samples[i] <- y
xx_samples = x_samples[(burn+1):N] # 取1001-5000样本
yy_samples = y_samples[(burn+1):N]
}
return(list(xx_samples = xx_samples, yy_samples = yy_samples))
}
# 2. 进行统计推断
statistical_analysis <- function(samples) {
xx = samples$xx_samples
yy = samples$yy_samples
x_mean <- mean(xx)
y_mean <- mean(yy)
x_var <- var(xx)
y_var <- var(yy)
return(list(x_mean = x_mean, y_mean = y_mean, x_var = x_var, y_var = y_var))
}
# 3. 输出结果，包括轨迹图和直方图
plot_results <- function(samples) {
par(mfrow = c(5, 5, 2, 2))
# x 和 y 的轨迹图
plot(samples$xx_samples, type = "l", main = "Trace of x", xlab = "Iteration", ylab = "x")
plot(samples$yy_samples, type = "l", main = "Trace of y", xlab = "Iteration", ylab = "y")
# x 和 y 的直方图
hist(samples$xx_samples, breaks = seq(-0.5, n + 0.5, by = 1), main = "Histogram of x", xlab = "x", probability = TRUE)
hist(samples$yy_samples, breaks = 30, main = "Histogram of y", xlab = "y", probability = TRUE)
}
# 主程序
samples <- generate_samples(n, a, b, N)        # 生成样本
analysis_results <- statistical_analysis(samples)        # 统计推断
plot_results(samples)                                    # 输出结果
# 设置参数
n <- 10      # 样本大小
a <- 2       # Beta分布的参数
b <- 2       # Beta分布的参数
N <- 5000  # Gibbs采样的迭代次数
burn = 1000
# 1. 生成Gibbs采样的数据
generate_samples <- function(n, a, b, iterations) {
x_samples <- numeric(iterations)
y_samples <- numeric(iterations)
y <- 0.5  # 初始化 y 的初始值
for (i in 1:iterations) {
x <- rbinom(1, n, y)              # 从 x | y 的条件分布采样
y <- rbeta(1, x + a, n - x + b)   # 从 y | x 的条件分布采样
x_samples[i] <- x
y_samples[i] <- y
xx_samples = x_samples[(burn+1):N] # 取1001-5000样本
yy_samples = y_samples[(burn+1):N]
}
return(list(xx_samples = xx_samples, yy_samples = yy_samples))
}
# 2. 进行统计推断
statistical_analysis <- function(samples) {
xx = samples$xx_samples
yy = samples$yy_samples
x_mean <- mean(xx)
y_mean <- mean(yy)
x_var <- var(xx)
y_var <- var(yy)
return(list(x_mean = x_mean, y_mean = y_mean, x_var = x_var, y_var = y_var))
}
# 3. 输出结果，包括轨迹图和直方图
plot_results <- function(samples) {
par(mfrow = c( 2, 2))
# x 和 y 的轨迹图
plot(samples$xx_samples, type = "l", main = "Trace of x", xlab = "Iteration", ylab = "x")
plot(samples$yy_samples, type = "l", main = "Trace of y", xlab = "Iteration", ylab = "y")
# x 和 y 的直方图
hist(samples$xx_samples, breaks = seq(-0.5, n + 0.5, by = 1), main = "Histogram of x", xlab = "x", probability = TRUE)
hist(samples$yy_samples, breaks = 30, main = "Histogram of y", xlab = "y", probability = TRUE)
}
# 主程序
samples <- generate_samples(n, a, b, N)        # 生成样本
analysis_results <- statistical_analysis(samples)        # 统计推断
plot_results(samples)                                    # 输出结果
# 打印统计推断的结果
print(analysis_results)
library(Rcpp)
devtools::load_all()
devtools::document()
devtools::check()
# 加载需要的库
library(grid)
# 读取图片文件
img <- readJPEG("Exercise-Proof.jpg")
grid.newpage()
# 插入图片
grid.raster(img)
devtools::check()
devtools::check()
devtools::check()
devtools::build_vignettes()
devtools::build(vignettes=FALSE)
install.packages('../SA24204124_1.0.tar.gz',repo=NULL)
install.packages('../StatComp_1.0.tar.gz',repo=NULL)
install.packages('../SA24204124_1.0.tar.gz',repo=NULL)
install.packages('../SA24204124_1.0.tar.gz',repo=NULL)
devtools::document()
devtools::install_github("dongyuning18/SA24204124")
devtools::install_github("dongyuning18/SA24204124@main")
devtools::install_github("dongyuning18/SA24204124@master")
git clone https://github.com/dongyuning18/SA24204124.git
setwd("SA24204124")
devtools::install()
install.packages('xfun')
packageVersion("xfun")
devtools::install()
devtools::install_github("dongyuning18/SA24204124")
devtools::install_github("dongyuning18/SA24204124@master")
devtools::install_github("CCLLYS/SA24204125")
install.packages('glue')
devtools::install_github("CCLLYS/SA24204125")
devtools::install_github("CCLLYS/SA24204125", force = TRUE)
packageVersion("glue")
install.packages('withr')
devtools::install_github("CCLLYS/SA24204125", force = TRUE)
devtools::install_github("dongyuning18/SA24204124@master")
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
devtools::install_github("CCLLYS/SA24204125", force = TRUE)
view(SA24204125)
View(SA24204125)
?SA2420412
??SA24204125
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
devtools::install_github("dongyuning18/SA24204124")
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
install.packages('curl')
install.packages('fs')
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
data(data)
SP_Return = data$SP_Return; GDP = data$GDP; Inflation = data$Inflation; Unemployment = data$Unemployment
data(data)
Year = data$Year; SP_Return = data$SP_Return; GDP = data$GDP; Inflation = data$Inflation; Unemployment = data$Unemployment
load("C:/Users/36070/g1/tjjs/SA24204124/data/data.rda")
load("C:/Users/36070/g1/tjjs/SA24204124/data/df.rda")
load("C:/Users/36070/g1/tjjs/SA24204124/data/ranges.rda")
predict_stock_market_risk <- function(stock_returns, x1, x2, x3, window_size = 80) {
n <- length(stock_returns)
#检查输入的参数长度是否一致
if (n != length(x1) || n != length(x2) || n != length(x3)) {
stop("All input data vectors must have the same length.")
}
# 检查窗口大小是否合法
if (window_size <= 0 || window_size > n) {
stop("Window size must be a positive integer and smaller than or equal to the length of the data.")
}
#存储风险预测结果
risk_predictions <- numeric(n - window_size + 1)
for (i in 1:(n - window_size + 1)) {
# 提取当前窗口的数据
current_window_stock_returns <- stock_returns[i:(i + window_size - 1)]
current_window1 <- x1[i:(i + window_size - 1)]
current_window2 <- x2[i:(i + window_size - 1)]
current_window3 <- x3[i:(i + window_size - 1)]
# 检查窗口内是否包含NA值
if (any(is.na(current_window_stock_returns)) || any(is.na(current_window1)) ||
any(is.na(current_window2)) || any(is.na(current_window3))) {
risk_predictions[i] <- NA  # 如果窗口内有NA值，设置风险为NA
next
}
# 计算当前窗口股市收益率的标准差作为风险
current_risk <- sd(current_window_stock_returns)
# 将经济因素（x1, x2, x3）合并成一个数据框
data <- data.frame(current_risk = rep(current_risk, length(current_window1)), x1 = current_window1, x2 = current_window2, x3 = current_window3)
# 多元线性回归：股市风险 ~ GDP + 通货膨胀率 + 失业率
model <- lm(current_risk ~ x1 + x2 + x3, data = data)
# 提取回归模型的系数
coefficients <- coef(model)
# 计算回归模型的预测值（即股市风险）
predicted_risk <- sum(coefficients[-1] * c(mean(current_window1), mean(current_window2), mean(current_window3))) + coefficients[1]
# 存储预测的风险值
risk_predictions[i] <- predicted_risk
}
# 输出预测结果和统计信息
result <- list(
risk_predictions = risk_predictions,
mean_risk = mean(risk_predictions, na.rm = TRUE),
sd_risk = sd(risk_predictions, na.rm = TRUE),
min_risk = min(risk_predictions, na.rm = TRUE),
max_risk = max(risk_predictions, na.rm = TRUE)
)
return(result)
}
data(data)
Year = data$Year; SP_Return = data$SP_Return; GDP = data$GDP; Inflation = data$Inflation; Unemployment = data$Unemployment
plot(Year, SP_Return, col = 'blue', type = 'l', lwd = 2, main = 'data', ylim = c(-1,15))
lines(Year, GDP, col = 'red', lwd = 2)
lines(Year, Inflation, col = 'green', lwd = 2)
lines(Year, Unemployment, col = 'yellow', lwd = 2)
legend("topleft", legend = c("SP500 yearly return", "GDP growth", "Inflation", "Unemployment rate"),
col = c("blue", "red", "green", "yellow"), lwd = 2)
devtools::check()
rm(list = c("predict_stock_market_risk"))
devtools::check()
predict_stock_market_risk <- function(stock_returns, x1, x2, x3, window_size = 80) {
n <- length(stock_returns)
#检查输入的参数长度是否一致
if (n != length(x1) || n != length(x2) || n != length(x3)) {
stop("All input data vectors must have the same length.")
}
# 检查窗口大小是否合法
if (window_size <= 0 || window_size > n) {
stop("Window size must be a positive integer and smaller than or equal to the length of the data.")
}
#存储风险预测结果
risk_predictions <- numeric(n - window_size + 1)
for (i in 1:(n - window_size + 1)) {
# 提取当前窗口的数据
current_window_stock_returns <- stock_returns[i:(i + window_size - 1)]
current_window1 <- x1[i:(i + window_size - 1)]
current_window2 <- x2[i:(i + window_size - 1)]
current_window3 <- x3[i:(i + window_size - 1)]
# 检查窗口内是否包含NA值
if (any(is.na(current_window_stock_returns)) || any(is.na(current_window1)) ||
any(is.na(current_window2)) || any(is.na(current_window3))) {
risk_predictions[i] <- NA  # 如果窗口内有NA值，设置风险为NA
next
}
# 计算当前窗口股市收益率的标准差作为风险
current_risk <- sd(current_window_stock_returns)
# 将经济因素（x1, x2, x3）合并成一个数据框
data <- data.frame(current_risk = rep(current_risk, length(current_window1)), x1 = current_window1, x2 = current_window2, x3 = current_window3)
# 多元线性回归：股市风险 ~ GDP + 通货膨胀率 + 失业率
model <- lm(current_risk ~ x1 + x2 + x3, data = data)
# 提取回归模型的系数
coefficients <- coef(model)
# 计算回归模型的预测值（即股市风险）
predicted_risk <- sum(coefficients[-1] * c(mean(current_window1), mean(current_window2), mean(current_window3))) + coefficients[1]
# 存储预测的风险值
risk_predictions[i] <- predicted_risk
}
# 输出预测结果和统计信息
result <- list(
risk_predictions = risk_predictions,
mean_risk = mean(risk_predictions, na.rm = TRUE),
sd_risk = sd(risk_predictions, na.rm = TRUE),
min_risk = min(risk_predictions, na.rm = TRUE),
max_risk = max(risk_predictions, na.rm = TRUE)
)
return(result)
}
# 示例数据生成
library(SA24204124)
set.seed(123)  # 设置随机种子确保可重复性
stock_returns <- rnorm(200)  # 模拟100个股市收益率
gdp_growth <- rnorm(200)  # 模拟100个GDP增长率
inflation_rate <- rnorm(200)  # 模拟100个通货膨胀率
unemployment_rate <- rnorm(200)  # 模拟100个失业率
# 调用函数进行风险预测
result <- predict_stock_market_risk(stock_returns, gdp_growth, inflation_rate, unemployment_rate, window_size = 80)
# 查看结果
print("风险预测结果：")
print(result$risk_predictions)  # 每个窗口的风险预测
print("预测统计信息：")
print(result$mean_risk)  # 风险的均值
print(result$sd_risk)    # 风险的标准差
print(result$min_risk)   # 风险的最小值
print(result$max_risk)   # 风险的最大值
# 查看结果
plot(result$risk_predictions, type = "l", col = "blue", main = "Predicted Stock Market Risk", ylab = "Risk Value", xlab = "Time")
data(data)
Year = data$Year; SP_Return = data$SP_Return; GDP = data$GDP; Inflation = data$Inflation; Unemployment = data$Unemployment
plot(Year, SP_Return, col = 'blue', type = 'l', lwd = 2, main = 'data', ylim = c(-1,15))
lines(Year, GDP, col = 'red', lwd = 2)
lines(Year, Inflation, col = 'green', lwd = 2)
lines(Year, Unemployment, col = 'yellow', lwd = 2)
legend("topleft", legend = c("SP500 yearly return", "GDP growth", "Inflation", "Unemployment rate"),
col = c("blue", "red", "green", "yellow"), lwd = 2)
data(data)
SP_Return = data$SP_Return; GDP = data$GDP; Inflation = data$Inflation; Unemployment = data$Unemployment
predict_stock_market_risk(SP_Return,GDP,Inflation,Unemployment,window_size=10)
r1 = predict_stock_market_risk(SP_Return,GDP,Inflation,Unemployment,window_size=10)$risk_predictions
plot(seq(2024,2038),r1,ylab = 'Stock Risk Value',type = 'l')
library(SA24204124)
df <- data.frame(
temp = c(25, 30, 35, 100, -60, 15),
pressure = c(1010, 1020, 1015, 1030, 1100, 1005)
)
# 指定合理的范围
ranges <- list(
temp = c(-50, 50),  # 温度应该在 -50 到 50 摄氏度之间
pressure = c(980, 1050)  # 气压应该在 980 到 1050 毫巴之间
)
# 检测异常值
r2 = rangeAnomalyDetection(df, value_ranges = ranges)
# 查看检测结果
print(r2)
library(SA24204124)
# 生成两组随机数数据
df2 <- data.frame(
d1 = runif(10, -30, 40), # 温度数据，包含一个极端值
d2 = runif(10, 900, 1100)  # 气压数据，包含一个极端值
)
# 打印数据框
print(df2)
# 调用 rangeAnomalyDetection 函数，检测异常值（不提供 value_ranges 参数，使用默认 IQR 计算范围）
r22 = rangeAnomalyDetection(df2)
# 显示异常值
print(r22)
library(SA24204124)
# 生成两组随机数数据
df2 <- data.frame(
d1 = runif(10, -30, 40), # 温度数据，包含一个极端值
d2 = runif(10, 900, 1100)  # 气压数据，包含一个极端值
)
# 打印数据框
print(df2)
# 调用 rangeAnomalyDetection 函数，检测异常值（不提供 value_ranges 参数，使用默认 IQR 计算范围）
r22 = rangeAnomalyDetection(df2)
# 显示异常值
print(r22)
library(SA24204124)
# 生成两组随机数数据
df2 <- data.frame(
d1 = runif(10, -30, 40), # 温度数据，包含一个极端值
d2 = runif(10, 900, 1100)  # 气压数据，包含一个极端值
)
# 打印数据框
print(df2)
# 调用 rangeAnomalyDetection 函数，检测异常值（不提供 value_ranges 参数，使用默认 IQR 计算范围）
r22 = rangeAnomalyDetection(df2)
# 显示异常值
print(r22)
devtools::check()
devtools::document()
rm(list = c("predict_stock_market_risk"))
devtools::check()
devtools::check()
devtools::build_vignettes()
devtools::build(vignettes=FALSE)
devtools::install_github("dongyuning18/SA24204124@master")
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
detach("package:SA24204124", unload = TRUE)
devtools::install_github("dongyuning18/SA24204124@master", force = TRUE)
??SA24204124
detach("package:SA24204124", unload = TRUE)
devtools::build_vignettes()
devtools::build(vignettes=FALSE)
